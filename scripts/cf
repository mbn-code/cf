#!/usr/bin/env bash

################################################################################
# cf - Production-grade Codeforces CLI Tool
#
# Main command-line interface for C++ competitive programming
#
# Usage:
#   cf template <name>         - Create new problem template
#   cf <name> [input]          - Compile and run solution
#   cf test                    - Run all tests with timeout protection
#   cf serve [problem]         - Start web interface
#
# Examples:
#   cf template 1000A          - Create src/1000A/ with solution.cpp
#   cf 1000A input.txt         - Compile and run with input.txt
#   cf 1000A "5\n1 2 3 4 5"    - Compile and run with inline input
#   cf test                    - Run all tests with timeout protection
#   cf serve                   - Start web interface
#   cf serve 1000A             - Create (if needed) and serve problem 1000A
#
# Features:
#   - Auto-detects .cpp files
#   - Handles multi-file compilation
#   - Timeout protection (prevents infinite loops)
#   - Input validation and error checking
#   - Cross-platform (Linux/macOS/WSL)
#   - Idempotent and robust
#   - Production-grade error handling
#
################################################################################

set -euo pipefail

# ==================== CONFIGURATION ====================

# Determine repository root (handle symlinks)
if [ -f "${BASH_SOURCE[0]}" ]; then
    SCRIPT_PATH="${BASH_SOURCE[0]}"
    if command -v readlink &> /dev/null;
        then
        SCRIPT_PATH="$(readlink -f "$SCRIPT_PATH" 2>/dev/null || printf '%s' "$SCRIPT_PATH")"
    fi
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    # If script is in the repo's scripts/ directory, use it
    if [ -f "$SCRIPT_DIR/../src/template.cpp" ]; then
        REPO_ROOT="$(dirname "$SCRIPT_DIR")"
    # Otherwise, use HOME-based fallback for global installation
    else
        REPO_ROOT="${CF_REPO_ROOT:-$HOME/Documents/GitHub/cf}"
    fi
else
    REPO_ROOT="${CF_REPO_ROOT:-$HOME/Documents/GitHub/cf}"
fi

SRC_DIR="$REPO_ROOT/src"
INCLUDE_DIR="$REPO_ROOT/include"
SCRIPTS_DIR="$REPO_ROOT/scripts"
BUILD_DIR="$REPO_ROOT/build"
TESTS_DIR="$REPO_ROOT/tests"

# Compiler selection: prefer g++, fall back to clang++
if command -v g++ &> /dev/null;
    then
    COMPILER="g++"
elif command -v clang++ &> /dev/null;
    then
    COMPILER="clang++"
else
    printf '%s\n' "Error: No C++ compiler found. Install g++ or clang++." >&2
    exit 1
fi

# Compiler flags for competitive programming
CXXFLAGS_DEFAULT="-std=c++23 -O2 -Wall -Wextra"

# Execution timeout (seconds)
EXEC_TIMEOUT_DEFAULT=5

# Color codes
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Logging
VERBOSE=${CF_VERBOSE:-0}

# Exit codes
EXIT_USAGE=2
EXIT_IO=3
EXIT_COMPILE=4
EXIT_RUNTIME=5
EXIT_UPDATE=6

# Config overrides (optional)
CF_CONFIG_FILE="${CF_CONFIG:-$REPO_ROOT/.cfconfig}"
if [ -f "$CF_CONFIG_FILE" ]; then
    # shellcheck disable=SC1090
    . "$CF_CONFIG_FILE"
fi

# Global variable to store compiler warnings
COMPILATION_WARNINGS=""

# Effective configuration
CXXFLAGS="${CF_CXXFLAGS:-$CXXFLAGS_DEFAULT}"
EXEC_TIMEOUT="${CF_TIMEOUT:-$EXEC_TIMEOUT_DEFAULT}"
BUILD_CACHE_DIR="${CF_BUILD_CACHE_DIR:-$BUILD_DIR/.cache}"

# ==================== HELPER FUNCTIONS ====================

print_error() {
    printf '%b\n' "${RED}Error: $1${NC}" >&2
}

print_success() {
    printf '%b\n' "${GREEN}Success: $1${NC}"
}

print_warning() {
    printf '%b\n' "${YELLOW}Warning: $1${NC}"
}

print_info() {
    printf '%b\n' "${BLUE}Info: $1${NC}"
}

print_debug() {
    if [ "$VERBOSE" -eq 1 ]; then
        printf '%b\n' "${BLUE}[DEBUG] $1${NC}" >&2
    fi
}

print_header() {
    printf '%b\n' "${BLUE}═══════════════════════════════════════${NC}"
    printf '%b\n' "${BLUE}$1${NC}"
    printf '%b\n' "${BLUE}═══════════════════════════════════════${NC}"
}

print_warnings_if_any() {
    if [ -n "${COMPILATION_WARNINGS:-}" ]; then
        printf "\n${YELLOW}Compilation Warnings:${NC}\n"
        printf '%s\n' "$COMPILATION_WARNINGS"
    fi
}

is_tty() {
    [ -t 0 ] && [ -t 1 ]
}

# Error handling with context
error_exit() {
    local msg="$1"
    local code="${2:-1}"
    print_error "$msg"
    exit "$code"
}

# Validate file exists
validate_file() {
    if [ ! -f "$1" ]; then
        error_exit "File not found: $1" "$EXIT_IO"
    fi
}

# Validate directory exists
validate_dir() {
    if [ ! -d "$1" ]; then
        error_exit "Directory not found: $1" "$EXIT_IO"
    fi
}

# Find .cpp files in a directory
find_cpp_files() {
    local dir="$1"
    find "$dir" -maxdepth 1 -name "*.cpp" -type f
}

# Check if directory exists
dir_exists() {
    [ -d "$1" ]
}

# Global flag to track if timeout warning has been shown
TIMEOUT_WARNING_SHOWN=0

# Check for timeout command availability
check_timeout_cmd() {
    if command -v timeout &> /dev/null;
        then
        TIMEOUT_CMD="timeout"
        return 0
    elif command -v gtimeout &> /dev/null;
        then
        TIMEOUT_CMD="gtimeout"
        return 0
    else
        if [ "$TIMEOUT_WARNING_SHOWN" -eq 0 ]; then
            print_warning "timeout command not found; execution timeout protection disabled"
            if command -v brew &> /dev/null;
                then
                print_info "Install on macOS: brew install coreutils"
            fi
            TIMEOUT_WARNING_SHOWN=1
        fi
        return 1
    fi
}

# Cleanup management (single trap)
CLEANUP_ITEMS=()
add_cleanup() {
    CLEANUP_ITEMS+=("$1")
}
run_cleanup() {
    local item
    for item in "${CLEANUP_ITEMS[@]}"; do
        rm -f "$item" 2>/dev/null || true
    done
}
trap 'run_cleanup' EXIT

# Hash sources for build cache
compute_sources_hash() {
    local sources=("$@")
    local hash_cmd=""
    if command -v sha256sum &> /dev/null;
        then
        hash_cmd="sha256sum"
    elif command -v shasum &> /dev/null;
        then
        hash_cmd="shasum -a 256"
    else
        return 1
    fi

    {
        printf '%s\n' "$CXXFLAGS"
        for s in "${sources[@]}"; do
            printf '%s\n' "$s"
            cat "$s"
        done
    } | eval "$hash_cmd" | awk '{print $1}'
}

# Safe execution with timeout and resource tracking
safe_execute() {
    local output_file=""
    if [[ "$1" == --output=* ]]; then
        output_file="${1#--output=}"
        shift
    fi
    local binary="$1"
    local input_file="${2:-}"
    local timeout_sec="${EXEC_TIMEOUT}"

    local time_log
    time_log=$(mktemp)
    add_cleanup "$time_log"

    local cmd=()
    if check_timeout_cmd; then
        cmd+=("$TIMEOUT_CMD" "$timeout_sec")
    fi
    cmd+=("$binary")

    local exit_code=0
    
    local use_time=0
    if [ -x "/usr/bin/time" ]; then
        # Check if /usr/bin/time supports the -f flag (GNU time)
        if /usr/bin/time -f "test" echo test &>/dev/null; then
            use_time=1
        fi
    fi

    if [ "$use_time" -eq 1 ]; then
        if [ -n "$output_file" ]; then
            if [ -n "$input_file" ] && [ -f "$input_file" ]; then
                /usr/bin/time -f "RESOURCE_USAGE: %e %M" -o "$time_log" "${cmd[@]}" < "$input_file" > "$output_file" 2>&1
            else
                /usr/bin/time -f "RESOURCE_USAGE: %e %M" -o "$time_log" "${cmd[@]}" > "$output_file" 2>&1
            fi
        else
            if [ -n "$input_file" ] && [ -f "$input_file" ]; then
                /usr/bin/time -f "RESOURCE_USAGE: %e %M" -o "$time_log" "${cmd[@]}" < "$input_file" 2>&1
            else
                /usr/bin/time -f "RESOURCE_USAGE: %e %M" -o "$time_log" "${cmd[@]}" 2>&1
            fi
        fi
        exit_code=$?
        # Print resource usage to stdout for the web UI to capture
        cat "$time_log" 2>/dev/null || true
    else
        if [ -n "$output_file" ]; then
            if [ -n "$input_file" ] && [ -f "$input_file" ]; then
                "${cmd[@]}" < "$input_file" > "$output_file" 2>&1
            else
                "${cmd[@]}" > "$output_file" 2>&1
            fi
        else
            if [ -n "$input_file" ] && [ -f "$input_file" ]; then
                "${cmd[@]}" < "$input_file" 2>&1
            else
                "${cmd[@]}" 2>&1
            fi
        fi
        exit_code=$?
    fi

    if [ $exit_code -eq 124 ]; then
        print_error "Execution timeout (exceeded ${timeout_sec}s)"
        return 1
    elif [ $exit_code -ne 0 ]; then
        # We don't always want to return 1 here because some solutions might return non-zero but still be correct (though rare in CP)
        # But for Codeforces, exit code should be 0.
        print_error "Runtime error (exit code: $exit_code)"
        return 1
    fi
    return 0
}

# Compile with error reporting
safe_compile() {
    local output="$1"
    shift
    local sources=("$@")

    print_debug "Compiling: ${sources[*]} -> $output"

    # Clear previous warnings
    COMPILATION_WARNINGS=""

    local compile_out
    compile_out=$($COMPILER $CXXFLAGS -I "$INCLUDE_DIR" "${sources[@]}" -o "$output" 2>&1)
    local ret=$?

    if [ $ret -ne 0 ]; then
        [ -n "$compile_out" ] && printf '%s\n' "$compile_out"
        print_error "Compilation failed"
        return $ret
    fi

    # Store warnings for later
    COMPILATION_WARNINGS="$compile_out"

    return 0
}

# Extract example block (input or output) from problem description file
extract_example_block() {
    local file="$1"
    local sample_index="${2:-1}"
    local target="$3"

    if [ ! -f "$file" ]; then
        return 1
    fi

    # Check if this looks like a problem description with Examples section
    if grep -qi "Examples\|Example" "$file" 2>/dev/null;
        then
        awk -v idx="$sample_index" -v target="$target" '
            function norm(s){ gsub(/\r/, "", s); return s }
            function trim(s){ sub(/^[[:space:]]+/, "", s); sub(/[[:space:]]+$/, "", s); return s }
            function norm_head(s){ s=tolower(s); gsub(/[[:space:]]+/, " ", s); s=trim(s); return s }
            function is_head(s, name){ s=norm_head(s); name=tolower(name); return (s==name || s==name":" || s==name" :") }
            function is_input_head(s){ return is_head(s, "input") || is_head(s, "sample input") }
            function is_output_head(s){ return is_head(s, "output") || is_head(s, "sample output") }
            function is_stop_head(s){ return is_head(s, "note") || is_head(s, "explanation") || is_head(s, "constraints") || is_head(s, "examples") }
            BEGIN { in_examples=0; in_block=0; printed=0; example_idx=0 }
            {
                line=norm($0)
                if (!in_examples && line ~ /^[[:space:]]*$/) next
                if (!in_examples && tolower(line) ~ /^examples?$/) { in_examples=1; next }
                if (!in_examples && tolower(line) ~ /^example[[:space:]]*[0-9]*$/) { in_examples=1; next }
                if (!in_examples) next

                if (is_input_head(line)) {
                    example_idx++
                    if (target=="input") {
                        in_block=(example_idx==idx)
                    } else {
                        if (in_block && example_idx > idx) exit
                        in_block=0
                    }
                    next
                }
                if (is_output_head(line)) {
                    if (target=="output") {
                        in_block=(example_idx==idx)
                    } else if (in_block) {
                        exit
                    }
                    next
                }
                if (target=="output" && is_stop_head(line)) { if (in_block) exit }

                if (in_block) {
                    if (tolower(trim(line))=="copy") next
                    print line
                    printed=1
                }
            }
            END { if (!printed) exit 1 }
        ' "$file"
    else
        return 1
    fi
}

# Extract test input from problem description file
extract_test_input() {
    local file="$1"
    local sample_index="${2:-1}"

    if [ ! -f "$file" ]; then
        print_debug "Problem file not found: $file"
        return 1
    fi

    if grep -qi "Examples\|Example" "$file" 2>/dev/null;
        then
        extract_example_block "$file" "$sample_index" "input"
    else
        # Regular input file, return as-is
        cat "$file"
    fi
}

# Extract expected output from problem description file
extract_expected_output() {
    local file="$1"
    local sample_index="${2:-1}"

    if [ ! -f "$file" ]; then
        return 1
    fi

    if grep -qi "Examples\|Example" "$file" 2>/dev/null;
        then
        extract_example_block "$file" "$sample_index" "output"
    else
        return 1
    fi
}

# Count sample inputs in a problem statement
count_samples() {
    local file="$1"

    if [ ! -f "$file" ]; then
        return 0
    fi

    if ! grep -qi "Examples\|Example" "$file" 2>/dev/null;
        then
        printf '0'
        return 0
    fi

    awk '
        function norm(s){ gsub(/\r/, "", s); return s }
        function trim(s){ sub(/^[[:space:]]+/, "", s); sub(/[[:space:]]+$/, "", s); return s }
        function norm_head(s){ s=tolower(s); gsub(/[[:space:]]+/, " ", s); s=trim(s); return s }
        function is_head(s, name){ s=norm_head(s); name=tolower(name); return (s==name || s==name":" || s==name" :") }
        BEGIN { in_examples=0; count=0 }
        {
            line=norm($0)
            if (!in_examples && line ~ /^[[:space:]]*$/) next
            if (!in_examples && tolower(line) ~ /^examples?$/) { in_examples=1; next }
            if (!in_examples && tolower(line) ~ /^example[[:space:]]*[0-9]*$/) { in_examples=1; next }
            if (!in_examples) next

            if (is_head(line, "input") || is_head(line, "sample input")) { count++ }
        }
        END { print count }
    ' "$file"
}

# Normalize output for comparison: strip \r, trim blank edges, trim trailing spaces per line
normalize_output() {
    printf '%s' "$1" | tr -d '\r' | awk '
        { sub(/[[:space:]]+$/, "", $0); lines[NR]=$0 }
        END {
            start=1; end=NR
            while (start<=NR && lines[start] ~ /^[[:space:]]*$/) start++
            while (end>=start && lines[end] ~ /^[[:space:]]*$/) end--
            for (i=start; i<=end; i++) {
                if (i>start) printf "\n"
                printf "%s", lines[i]
            }
        }
    '
}

# ==================== TEMPLATE COMMAND ====================

cmd_template() {
    local problem_name="$1"

    if [ -z "$problem_name" ]; then
        print_error "Usage: cf template <name>"
        printf '%s\n' "Example: cf template 1000A"
        return 1
    fi

    # Validate problem name format
    if ! [[ "$problem_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Invalid problem name: $problem_name (use alphanumeric, dash, or underscore)"
        return 1
    fi

    # Create problem directory in current working directory
    local problem_dir="$PWD/$problem_name"

    if dir_exists "$problem_dir"; then
        print_info "Problem directory already exists: $problem_dir"
    else
        mkdir -p "$problem_dir" || error_exit "Failed to create directory: $problem_dir" "$EXIT_IO"
        print_success "Created directory: $problem_dir"
    fi

    # Copy template to solution.cpp
    local solution_file="$problem_dir/solution.cpp"

    if [ -f "$solution_file" ]; then
        print_info "Solution already exists: $solution_file"
    else
        if [ -f "$SRC_DIR/template.cpp" ]; then
            cp "$SRC_DIR/template.cpp" "$solution_file" || error_exit "Failed to copy template" "$EXIT_IO"
            print_success "Created solution: $solution_file"
        else
            error_exit "Template file not found: $SRC_DIR/template.cpp" "$EXIT_IO"
        fi
    fi

    # Create problem.txt file
    local problem_file="$problem_dir/problem.txt"

    if [ -f "$problem_file" ]; then
        print_info "Problem file already exists: $problem_file"
    else
        cat > "$problem_file" << 'EOF' || error_exit "Failed to create problem file" "$EXIT_IO"
# Paste the problem statement here from Codeforces

Examples
Input


Output


EOF
        print_success "Created problem file: $problem_file"
    fi

    # Compile to verify setup
    print_info "Verifying compilation..."
    local output_file
    output_file=$(mktemp) || error_exit "Failed to create temp file" "$EXIT_IO"
    add_cleanup "$output_file"

    if safe_compile "$output_file" "$solution_file"; then
        print_success "Compilation verified"
    else
        error_exit "Compilation failed. Check your C++ compiler." "$EXIT_COMPILE"
    fi

    # Open files in VS Code if available
    if [ "${CF_SERVE_MODE:-0}" -eq 0 ] && command -v code &> /dev/null;
        then
        print_info "Opening files in VS Code..."
        code "$problem_file" "$solution_file" 2>/dev/null || true
        print_success "Opened in VS Code"
    fi

    if [ "${CF_SERVE_MODE:-0}" -eq 0 ]; then
        printf '\n'
        printf '%s\n' "Next steps:"
        printf '%s\n' "  1. Paste problem statement in $problem_file"
        printf '%s\n' "  2. Edit solution in $solution_file"
        printf '%s\n' "  3. cd $problem_name && cf problem.txt"
    fi
}

# ==================== RUN COMMAND ====================

cmd_run() {
    local input_arg=""
    local sample_index="1"
    local use_stdin=0
    local sample_set=0

    while [ $# -gt 0 ]; do
        case "$1" in
            --sample|-s)
                shift || true
                if [ -z "${1:-}" ]; then
                    error_exit "Missing value for --sample" "$EXIT_USAGE"
                fi
                sample_index="$1"
                sample_set=1
                ;; 
            --input|--file|-i)
                shift || true
                if [ -z "${1:-}" ]; then
                    error_exit "Missing value for --input" "$EXIT_USAGE"
                fi
                input_arg="$1"
                ;; 
            --stdin)
                use_stdin=1
                ;; 
            --help|-h)
                cmd_help
                return 0
                ;; 
            *)
                if [ -z "$input_arg" ]; then
                    input_arg="$1"
                elif [[ "$1" =~ ^[0-9]+$ ]] && [ "$sample_set" -eq 0 ] && [ -f "$input_arg" ]; then
                    sample_index="$1"
                else
                    print_warning "Ignoring extra argument: $1"
                fi
                ;; 
        esac
        shift || true
    done

    if ! [[ "$sample_index" =~ ^[0-9]+$ ]] || [ "$sample_index" -lt 1 ]; then
        error_exit "Invalid sample index: $sample_index" "$EXIT_USAGE"
    fi

    # Handle directory as input_arg
    if [ -n "$input_arg" ] && [ ! -f "$input_arg" ]; then
        if [ -d "$input_arg" ] && [ -f "$input_arg/problem.txt" ]; then
            input_arg="$input_arg/problem.txt"
        elif [ -d "$SRC_DIR/$input_arg" ] && [ -f "$SRC_DIR/$input_arg/problem.txt" ]; then
            input_arg="$SRC_DIR/$input_arg/problem.txt"
        elif [ "$(basename "$PWD")" = "$input_arg" ] && [ -f "$PWD/problem.txt" ]; then
            input_arg="$PWD/problem.txt"
        fi
    fi

    if [ "$use_stdin" -eq 0 ] && [ -z "$input_arg" ] && [ -f "$PWD/problem.txt" ]; then
        input_arg="$PWD/problem.txt"
    fi

    # Find .cpp files in current directory
    cpp_files=()
    while IFS= read -r file; do
        [ -n "$file" ] && cpp_files+=("$file")
    done < <(find "$PWD" -maxdepth 1 -name "*.cpp" -type f 2>/dev/null)
    if [ ${#cpp_files[@]} -eq 0 ]; then
        error_exit "No C++ file found in current directory ($PWD)" "$EXIT_USAGE"
    fi

    print_info "Using: ${#cpp_files[@]} source file(s)"

    # Prepare output file (build cache)
    local output_file
    local sources_hash=""
    sources_hash=$(compute_sources_hash "${cpp_files[@]}") || true
    if [ -n "$sources_hash" ]; then
        mkdir -p "$BUILD_CACHE_DIR" || error_exit "Failed to create build cache directory" "$EXIT_IO"
        output_file="$BUILD_CACHE_DIR/$sources_hash"
    else
        output_file=$(mktemp) || error_exit "Failed to create temp file" "$EXIT_IO"
        add_cleanup "$output_file"
    fi

    # Compile
    if [ -x "$output_file" ] && [ -n "$sources_hash" ] && [ "${CF_FORCE_REBUILD:-0}" -ne 1 ]; then
        print_info "Using cached build"
    else
        print_info "Compiling with $COMPILER..."
        if ! safe_compile "$output_file" "${cpp_files[@]}"; then
            rm -f "$output_file" 2>/dev/null || true
            return 1
        fi
        chmod +x "$output_file" 2>/dev/null || true
        print_success "Compiled successfully"
    fi

    # Prepare input
    local input_data=""
    local expected_output=""
    local is_problem_file=false
    local temp_input=""
    local compare_enabled=false

    if [ "$use_stdin" -eq 1 ]; then
        print_info "Running with stdin (forced)"
    elif [ -n "$input_arg" ]; then
        if [ -f "$input_arg" ]; then
            # Input is a file - extract test input intelligently
            print_info "Running with input from: $input_arg"

            # Check if this is a problem file and extract expected output
            if grep -qi "Examples\|Example" "$input_arg" 2>/dev/null;
                then
                is_problem_file=true
                local sample_count
                sample_count=$(count_samples "$input_arg")
                if [ "$sample_count" -gt 0 ] && [ "$sample_index" -gt "$sample_count" ]; then
                    print_warning "Requested sample #$sample_index, but only $sample_count found; using sample #1"
                    sample_index=1
                fi
                expected_output=$(extract_expected_output "$input_arg" "$sample_index") || true
            fi

            # Create temp input file and write extracted input directly
            temp_input=$(mktemp) || error_exit "Failed to create temp input file" "$EXIT_IO"
            if ! extract_test_input "$input_arg" "$sample_index" > "$temp_input"; then
                print_warning "No sample input found in examples; falling back to samples/ or stdin"
                rm -f "$temp_input" 2>/dev/null || true
                temp_input=""
            fi

            if [ -z "$temp_input" ] && [ -d "$PWD/samples" ]; then
                local sample_in="$PWD/samples/${sample_index}.in"
                local sample_out="$PWD/samples/${sample_index}.out"
                if [ -f "$sample_in" ]; then
                    temp_input=$(mktemp) || error_exit "Failed to create temp input file" "$EXIT_IO"
                    cat "$sample_in" > "$temp_input"
                    if [ -f "$sample_out" ]; then
                        expected_output=$(cat "$sample_out")
                        is_problem_file=true
                    fi
                fi
            fi

            if [ -n "$temp_input" ]; then
                add_cleanup "$temp_input"
            else
                print_warning "No sample input found; falling back to interactive stdin"
            fi
        else
            # Input is a string (possibly with escaped newlines)
            print_info "Running with inline input"
            # Interpret escape sequences
            input_data=$(printf "%b" "$input_arg") || true

            # Create temp input file
            temp_input=$(mktemp) || error_exit "Failed to create temp input file" "$EXIT_IO"
            printf '%s' "$input_data" > "$temp_input"
            add_cleanup "$temp_input"
        fi
    else
        print_info "Running with stdin (pipe input or interactive)"
    fi

    # Execute with input
    printf '\n'
    if [ -n "$temp_input" ]; then
        print_info "Input Used:"
        printf -- '---\n'
        cat "$temp_input"
        printf -- '\n---\n'
    fi
    print_info "Your Output:"
    printf -- '---\n'

    local tmp_actual_output=""
    if [ -n "$temp_input" ]; then
        tmp_actual_output=$(mktemp)
        if ! safe_execute --output="$tmp_actual_output" "$output_file" "$temp_input"; then
            print_warnings_if_any
            return 1
        fi
        # Stream output directly to stdout, not through variable
        cat "$tmp_actual_output"
        compare_enabled=true
    else
        if ! safe_execute "$output_file"; then
            print_warnings_if_any
            return 1
        fi
    fi

    printf -- '\n---\n'

    # Display expected output if available
    if [ "$is_problem_file" = true ] && [ "$compare_enabled" = true ]; then
        if [ -n "$expected_output" ]; then
            printf '\n'
            print_info "Expected Output:"
            printf -- '---\n'
            printf '%s' "$expected_output"
            printf -- '\n---\n'

            # Create temporary file for normalization to avoid shell variable limitations with null bytes
            local tmp_normalized_actual
            local tmp_normalized_expected
            tmp_normalized_actual=$(mktemp)
            tmp_normalized_expected=$(mktemp)
            add_cleanup "$tmp_normalized_actual"
            add_cleanup "$tmp_normalized_expected"

            # Normalize outputs from files
            normalize_output "$(cat "$tmp_actual_output")" > "$tmp_normalized_actual"
            normalize_output "$expected_output" > "$tmp_normalized_expected"

            # Compare normalized outputs from files
            if cmp -s "$tmp_normalized_actual" "$tmp_normalized_expected"; then
                print_success "Output matches expected."
            else
                print_warning "Output does not match expected."
                rm -f "$tmp_actual_output" 2>/dev/null || true
                print_warnings_if_any
                return 1
            fi
        else
            print_warning "No sample output detected; skipping compare"
        fi
    elif [ "$is_problem_file" = true ] && [ "$compare_enabled" = false ]; then
        print_warning "Expected output available but input was interactive; skipping compare"
    fi

    # Cleanup
    rm -f "$tmp_actual_output" 2>/dev/null || true

    print_success "Execution complete"
}

# ==================== TEST COMMAND ====================

cmd_test_all() {
    local prob_dir="$1"
    local prob_file="$prob_dir/problem.txt"
    
    validate_dir "$prob_dir"
    validate_file "$prob_file"
    
    # Find .cpp files
    cpp_files=()
    while IFS= read -r file; do
        [ -n "$file" ] && cpp_files+=("$file")
    done < <(find "$prob_dir" -maxdepth 1 -name "*.cpp" -type f 2>/dev/null)
    if [ ${#cpp_files[@]} -eq 0 ]; then
        error_exit "No C++ file found in $prob_dir" "$EXIT_USAGE"
    fi

    print_info "Testing problem in: $prob_dir"
    print_info "Found ${#cpp_files[@]} source file(s)"

    # Compile
    local output_binary
    output_binary=$(mktemp)
    add_cleanup "$output_binary"
    
    print_info "Compiling..."
    if ! safe_compile "$output_binary" "${cpp_files[@]}"; then
        return 1
    fi
    chmod +x "$output_binary"

    local sample_count
    sample_count=$(count_samples "$prob_file")
    
    if [ "$sample_count" -eq 0 ]; then
        print_warning "No samples found in $prob_file"
        return 0
    fi

    print_info "Found $sample_count samples. Starting tests..."
    
    local passed=0
    local failed=0

    for ((i=1; i<=sample_count; i++)); do
        printf '\n'
        print_info "Running Sample #$i..."
        
        local temp_input
        local temp_expected
        local temp_actual
        temp_input=$(mktemp)
        temp_expected=$(mktemp)
        temp_actual=$(mktemp)
        add_cleanup "$temp_input"
        add_cleanup "$temp_expected"
        add_cleanup "$temp_actual"

        if ! extract_test_input "$prob_file" "$i" > "$temp_input"; then
            print_warning "Failed to extract input for sample #$i"
            continue
        fi
        
        local expected_data
        expected_data=$(extract_expected_output "$prob_file" "$i") || true
        printf '%s' "$expected_data" > "$temp_expected"

        if ! safe_execute --output="$temp_actual" "$output_binary" "$temp_input"; then
            print_error "Sample #$i: Runtime Error or Timeout"
            failed=$((failed + 1))
            continue
        fi

        # Compare
        local norm_actual
        local norm_expected
        norm_actual=$(mktemp)
        norm_expected=$(mktemp)
        add_cleanup "$norm_actual"
        add_cleanup "$norm_expected"
        
        normalize_output "$(cat "$temp_actual")" > "$norm_actual"
        normalize_output "$expected_data" > "$norm_expected"

        if cmp -s "$norm_actual" "$norm_expected"; then
            print_success "Sample #$i: PASSED"
            passed=$((passed + 1))
        else
            print_error "Sample #$i: FAILED (Output Mismatch)"
            printf "${YELLOW}Input Used:${NC}\n"
            cat "$temp_input" | sed 's/^/  /'
            printf "${YELLOW}Expected Output:${NC}\n"
            printf '%s\n' "$expected_data" | sed 's/^/  /'
            printf "${YELLOW}Your Output:${NC}\n"
            cat "$temp_actual" | sed 's/^/  /'
            
            # Show diff if possible
            if command -v diff &> /dev/null; then
                printf "${YELLOW}Diff:${NC}\n"
                diff -u "$norm_expected" "$norm_actual" | sed 's/^/  /' || true
            fi
            failed=$((failed + 1))
        fi
    done

    printf '\n'
    print_header "Test Summary"
    print_info "Total: $sample_count | Passed: ${GREEN}$passed${NC} | Failed: ${RED}$failed${NC}"
    
    if [ "$failed" -eq 0 ]; then
        print_success "All problem samples passed!"
        return 0
    else
        print_warnings_if_any
        return 1
    fi
}

cmd_test() {
    local arg="${1:-}"
    
    # Check if we are in a problem directory or argument is a problem
    local prob_dir=""
    if [ -f "$PWD/problem.txt" ]; then
        prob_dir="$PWD"
    elif [ -n "$arg" ]; then
        if [ -d "$PWD/$arg" ] && [ -f "$PWD/$arg/problem.txt" ]; then
            prob_dir="$PWD/$arg"
        elif [ -d "$SRC_DIR/$arg" ] && [ -f "$SRC_DIR/$arg/problem.txt" ]; then
            prob_dir="$SRC_DIR/$arg"
        fi
    fi

    if [ -n "$prob_dir" ]; then
        cmd_test_all "$prob_dir"
        return $?
    fi

    # Fallback to toolkit internal tests
    print_info "No problem context found. Running toolkit test suite..."

    if [ ! -f "$SCRIPTS_DIR/test.sh" ]; then
        print_warning "Test script not found: $SCRIPTS_DIR/test.sh"
        print_info "Using fallback: testing template.cpp"

        if [ ! -f "$SRC_DIR/template.cpp" ]; then
            error_exit "Template file not found" "$EXIT_IO"
        fi

        # Basic test
        local output_file
        output_file=$(mktemp) || error_exit "Failed to create temp file" "$EXIT_IO"
        add_cleanup "$output_file"

        if safe_compile "$output_file" "$SRC_DIR/template.cpp"; then
            print_success "Template compiles successfully"
        else
            return 1
        fi
    else
        bash "$SCRIPTS_DIR/test.sh"
    fi
}

# ==================== UPDATE COMMAND ====================

cmd_update() {
    print_info "Updating cf tool to latest version..."

    # Verify we're in a git repository
    if [ ! -d "$REPO_ROOT/.git" ]; then
        error_exit "Not a git repository: $REPO_ROOT" "$EXIT_UPDATE"
    fi

    # Save current directory
    local original_dir="$PWD"

    # Change to repository root
    cd "$REPO_ROOT" || error_exit "Failed to change to repository directory" 1

    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null;
        then
        print_warning "You have uncommitted changes in the repository"
        if [ "${CF_NONINTERACTIVE:-0}" -eq 1 ] || ! is_tty;
            then
            error_exit "Update aborted in non-interactive mode due to uncommitted changes" "$EXIT_UPDATE"
        fi
        printf '%s' "Continue with update? (y/N): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            print_info "Update cancelled"
            cd "$original_dir" || true
            return 0
        fi
    fi

    # Determine upstream
    local current_branch
    local upstream
    local remote
    local remote_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)
    upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)
    if [ -z "$upstream" ] && [ -n "$current_branch" ]; then
        upstream="origin/$current_branch"
    fi
    if [ -z "$upstream" ]; then
        error_exit "Unable to determine upstream branch" "$EXIT_UPDATE"
    fi
    remote="${upstream%%/*}"
    remote_branch="${upstream#*/}"

    # Fetch and pull latest changes
    print_info "Fetching latest changes from $remote..."
    if ! git fetch "$remote" 2>&1;
        then
        error_exit "Failed to fetch from remote repository" "$EXIT_UPDATE"
    fi

    print_info "Pulling latest changes from $remote/$remote_branch..."
    if ! git pull "$remote" "$remote_branch" 2>&1;
        then
        error_exit "Failed to pull latest changes" "$EXIT_UPDATE"
    fi

    print_success "Repository updated successfully"

    # Run setup script if it exists
    if [ -f "$SCRIPTS_DIR/setup.sh" ]; then
        print_info "Running setup script..."
        if bash "$SCRIPTS_DIR/setup.sh"; then
            print_success "Setup completed successfully"
        else
            print_warning "Setup script encountered issues, but update completed"
        fi
    else
        print_warning "Setup script not found, skipping setup"
    fi

    # Return to original directory
    cd "$original_dir" || true

    printf '\n'
    print_success "cf tool updated to latest version!"
    printf '%s\n' "Run 'cf help' to see all available commands"
}

# ==================== SERVE COMMAND ====================

cmd_serve() {
    local problem_name="${1:-}"
    local problems_dir="${CF_PROBLEMS_DIR:-}"

    if [ -z "$problems_dir" ]; then
        if [ -n "$problem_name" ] && [ -d "$PWD/$problem_name" ]; then
            problems_dir="$PWD"
        elif [ -n "$problem_name" ] && [ -d "$SRC_DIR/$problem_name" ]; then
            problems_dir="$SRC_DIR"
        elif [ "$PWD" != "$REPO_ROOT" ] && [ "$PWD" != "$SCRIPTS_DIR" ] && [ "$PWD" != "$SRC_DIR" ]; then
            problems_dir="$PWD"
        else
            problems_dir="$SRC_DIR"
        fi
    fi

    # Ensure absolute path
    problems_dir="$(cd "$problems_dir" 2>/dev/null && pwd || echo "$problems_dir")"

    if [ -n "$problem_name" ]; then
        if [ ! -d "$problems_dir/$problem_name" ]; then
            print_info "Problem $problem_name not found in $problems_dir. Creating from template..."
            (cd "$problems_dir" && CF_SERVE_MODE=1 cmd_template "$problem_name")
        fi
        export CF_START_PROBLEM="$problem_name"
    fi

    export CF_PROBLEMS_DIR="$problems_dir"
    export CF_SERVE_MODE=1
    
    print_info "Starting CF Toolkit Web Interface..."
    print_info "Problems directory: $problems_dir"
    
    if [ ! -d "$REPO_ROOT/web" ]; then
        error_exit "Web interface directory not found: $REPO_ROOT/web" "$EXIT_IO"
    fi

    cd "$REPO_ROOT/web"
    
    if [ ! -d "node_modules" ]; then
        print_info "Installing dependencies..."
        npm install
    fi

    # Use exec to replace the shell process and ensure signals are handled
    exec npm run dev
}

# ==================== HELP COMMAND ====================

cmd_help() {
    cat << 'EOF'
cf - Codeforces CLI Tool

USAGE:
  cf <command> [args]
    cf [input] [--sample N] [--input FILE] [--stdin]

COMMANDS:
  template <name>    Create new problem template
  test               Run test suite with validation
  serve [name]       Start web interface (auto-creates problem if name given)
  update             Update cf tool to latest version
  help               Show this help message

EXAMPLES:
  cf template 1000A           Create new problem 1000A
  cf serve                    Start web interface
  cf serve 1000A              Create (if needed) and serve 1000A in web
  cf problem.txt              Run solution with input from file
  cf problem.txt 2            Run sample #2 from problem.txt
  cf --sample 2               Run sample #2 from problem.txt (auto)
    cf --input input.txt         Run with explicit input file
    cf --stdin                   Force interactive stdin
  cf "5\n1 2 3 4 5"           Run solution with inline input
  cf test                     Run test suite

FEATURES:
    - Auto-detects .cpp files in current directory
    - Auto-uses problem.txt when present
    - Supports multiple samples with --sample N
    - Timeout protection (5s) prevents infinite loops
    - Validates input and handles errors gracefully
    - Compares output with expected results
    - Build caching for faster repeated runs
    - Cross-platform (Linux/macOS/WSL)
    - Production-grade reliability
    - Web Interface with 'cf serve'

ENVIRONMENT:
  CF_REPO_ROOT        Override repository root directory
  CF_PROBLEMS_DIR     Directory containing problem folders
  CF_VERBOSE          Set to 1 for debug output
    CF_CXXFLAGS         Override compiler flags
    CF_TIMEOUT          Override execution timeout (seconds)
    CF_BUILD_CACHE_DIR  Override build cache location
    CF_FORCE_REBUILD    Force rebuild (set to 1)
    CF_NONINTERACTIVE   Disable prompts (set to 1)

NEXT STEPS:
  1. Start web interface: cf serve
  2. Or CLI: cf template 1000A
  3. Edit solution.cpp and run: cf problem.txt

For more information, visit: https://github.com/mbn-code/cf

EOF
}

# ==================== MAIN ENTRY POINT ====================

main() {
    # Parse command
    local command="${1:-}"
    shift || true

    case "$command" in
        template)
            # Validate repo structure for template command
            if [ ! -d "$SRC_DIR" ]; then
                error_exit "Repository structure not found. Expected $SRC_DIR" 2
            fi
            cmd_template "$@"
            ;; 
        test)
            # Validate repo structure for test command
            if [ ! -d "$SRC_DIR" ]; then
                error_exit "Repository structure not found. Expected $SRC_DIR" 2
            fi
            cmd_test "$@"
            ;; 
        serve)
            cmd_serve "$@"
            ;;
        update)
            cmd_update "$@"
            ;; 
        help|--help|-h)
            cmd_help
            ;; 
        "")
            # Auto-detect problem.txt if no args given
            if [ -f "$PWD/problem.txt" ]; then
                cmd_run
            else
                print_error "Usage: cf <command> [args]"
                printf '\n'
                printf '%s\n' "Commands:"
                printf '%s\n' "  cf template <name>     Create new problem template"
                printf '%s\n' "  cf [input]             Compile and run solution"
                printf '%s\n' "  cf test                Run test suite"
                printf '%s\n' "  cf update              Update to latest version"
                printf '%s\n' "  cf help                Show help"
                printf '\n'
                printf '%s\n' "For more information: cf help"
                return 1
            fi
            ;; 
        *)
            cmd_run "$command" "$@"
            ;; 
    esac
}

main "$@"