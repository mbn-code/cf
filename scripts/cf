#!/bin/bash

################################################################################
# cf - Production-grade Codeforces CLI Tool
#
# Main command-line interface for C++ competitive programming
#
# Usage:
#   cf template <name>         - Create new problem template
#   cf <name> [input]          - Compile and run solution
#   cf test                    - Run test suite with validation
#   cf help                    - Show help
#
# Examples:
#   cf template 1000A          - Create src/1000A/ with solution.cpp
#   cf 1000A input.txt         - Compile and run with input.txt
#   cf 1000A "5\n1 2 3 4 5"    - Compile and run with inline input
#   cf test                    - Run all tests with timeout protection
#
# Features:
#   - Auto-detects .cpp files
#   - Handles multi-file compilation
#   - Timeout protection (prevents infinite loops)
#   - Input validation and error checking
#   - Cross-platform (Linux/macOS/WSL)
#   - Idempotent and robust
#   - Production-grade error handling
#
################################################################################

set -euo pipefail

# ==================== CONFIGURATION ====================

# Determine repository root
if [ -f "${BASH_SOURCE[0]}" ]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    # If script is in the repo's scripts/ directory, use it
    if [ -f "$SCRIPT_DIR/../src/template.cpp" ]; then
        REPO_ROOT="$(dirname "$SCRIPT_DIR")"
    # Otherwise, use HOME-based fallback for global installation
    else
        REPO_ROOT="${CF_REPO_ROOT:-$HOME/Documents/GitHub/cf}"
    fi
else
    REPO_ROOT="${CF_REPO_ROOT:-$HOME/Documents/GitHub/cf}"
fi

SRC_DIR="$REPO_ROOT/src"
INCLUDE_DIR="$REPO_ROOT/include"
SCRIPTS_DIR="$REPO_ROOT/scripts"
BUILD_DIR="$REPO_ROOT/build"
TESTS_DIR="$REPO_ROOT/tests"

# Compiler selection: prefer g++, fall back to clang++
if command -v g++ &> /dev/null; then
    COMPILER="g++"
elif command -v clang++ &> /dev/null; then
    COMPILER="clang++"
else
    echo "Error: No C++ compiler found. Install g++ or clang++." >&2
    exit 1
fi

# Compiler flags for competitive programming
CXXFLAGS="-std=c++23 -O2 -Wall -Wextra"

# Execution timeout (seconds)
EXEC_TIMEOUT=5

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging
VERBOSE=${CF_VERBOSE:-0}

# ==================== HELPER FUNCTIONS ====================

print_error() {
    echo -e "${RED}✗ Error: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

print_info() {
    echo -e "${BLUE}ℹ $1${NC}"
}

print_debug() {
    if [ "$VERBOSE" -eq 1 ]; then
        echo -e "${BLUE}[DEBUG] $1${NC}" >&2
    fi
}

# Error handling with context
error_exit() {
    local msg="$1"
    local code="${2:-1}"
    print_error "$msg"
    exit "$code"
}

# Validate file exists
validate_file() {
    if [ ! -f "$1" ]; then
        error_exit "File not found: $1" 2
    fi
}

# Validate directory exists
validate_dir() {
    if [ ! -d "$1" ]; then
        error_exit "Directory not found: $1" 2
    fi
}

# Find .cpp files in a directory
find_cpp_files() {
    local dir="$1"
    find "$dir" -maxdepth 1 -name "*.cpp" -type f
}

# Check if directory exists
dir_exists() {
    [ -d "$1" ]
}

# Check for timeout command availability
check_timeout_cmd() {
    if command -v timeout &> /dev/null; then
        return 0
    elif command -v gtimeout &> /dev/null; then
        return 0
    else
        print_warning "timeout command not found; execution timeout protection disabled"
        return 1
    fi
}

# Safe execution with timeout
safe_execute() {
    local binary="$1"
    local input_file="${2:-}"
    local timeout_sec="${EXEC_TIMEOUT}"
    
    if check_timeout_cmd; then
        if [ -n "$input_file" ] && [ -f "$input_file" ]; then
            timeout "$timeout_sec" "$binary" < "$input_file" 2>&1 || {
                local exit_code=$?
                if [ $exit_code -eq 124 ]; then
                    print_error "Execution timeout (exceeded ${timeout_sec}s)"
                    return 1
                elif [ $exit_code -ne 0 ]; then
                    print_error "Runtime error (exit code: $exit_code)"
                    return 1
                fi
            }
        else
            timeout "$timeout_sec" "$binary" 2>&1 || {
                local exit_code=$?
                if [ $exit_code -eq 124 ]; then
                    print_error "Execution timeout (exceeded ${timeout_sec}s)"
                    return 1
                elif [ $exit_code -ne 0 ]; then
                    print_error "Runtime error (exit code: $exit_code)"
                    return 1
                fi
            }
        fi
    else
        if [ -n "$input_file" ] && [ -f "$input_file" ]; then
            "$binary" < "$input_file" 2>&1
        else
            "$binary" 2>&1
        fi
    fi
    return 0
}

# Compile with error reporting
safe_compile() {
    local source="$1"
    local output="$2"
    
    print_debug "Compiling: $source -> $output"
    
    if ! $COMPILER $CXXFLAGS -I "$INCLUDE_DIR" "$source" -o "$output" 2>&1; then
        print_error "Compilation failed for $(basename "$source")"
        return 1
    fi
    
    return 0
}

# Extract test input from problem description file
extract_test_input() {
    local file="$1"
    
    if [ ! -f "$file" ]; then
        print_debug "Problem file not found: $file"
        return 1
    fi
    
    # Check if this looks like a problem description with Examples section
    if grep -qi "Examples" "$file" 2>/dev/null; then
        # Extract input between "Input" (after Examples) and "Output"
        awk '
            BEGIN { in_input = 0; in_example = 0 }
            /Examples/ { in_example = 1; next }
            in_example && /^Input$/ { in_input = 1; next }
            in_example && /^Copy$/ && in_input { next }
            in_example && in_input && /^Output$/ { exit }
            in_example && in_input && /^Copy$/ { exit }
            in_example && in_input && NF > 0 { print }
        ' "$file"
    else
        # Regular input file, return as-is
        cat "$file"
    fi
}

# Extract expected output from problem description file
extract_expected_output() {
    local file="$1"
    
    if [ ! -f "$file" ]; then
        return 1
    fi
    
    # Check if this looks like a problem description with Examples section
    if grep -qi "Examples" "$file" 2>/dev/null; then
        # Extract output between "Output" (after Examples) and next section
        awk '
            BEGIN { in_output = 0; in_example = 0; blank_count = 0 }
            /Examples/ { in_example = 1; next }
            in_example && /^Output$/ { in_output = 1; next }
            in_example && /^Copy$/ && in_output { next }
            in_example && in_output && /^$/ { 
                blank_count++
                if (blank_count >= 2) exit
                next
            }
            in_example && in_output && /^(Note|Explanation|Input)/ { exit }
            in_example && in_output && NF > 0 { print; blank_count = 0 }
        ' "$file"
    else
        return 1
    fi
}

# ==================== TEMPLATE COMMAND ====================

cmd_template() {
    local problem_name="$1"
    
    if [ -z "$problem_name" ]; then
        print_error "Usage: cf template <name>"
        echo "Example: cf template 1000A"
        return 1
    fi
    
    # Validate problem name format
    if ! [[ "$problem_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Invalid problem name: $problem_name (use alphanumeric, dash, or underscore)"
        return 1
    fi
    
    # Create problem directory in current working directory
    local problem_dir="$PWD/$problem_name"
    
    if dir_exists "$problem_dir"; then
        print_info "Problem directory already exists: $problem_dir"
    else
        mkdir -p "$problem_dir" || error_exit "Failed to create directory: $problem_dir" 1
        print_success "Created directory: $problem_dir"
    fi
    
    # Copy template to solution.cpp
    local solution_file="$problem_dir/solution.cpp"
    
    if [ -f "$solution_file" ]; then
        print_info "Solution already exists: $solution_file"
    else
        if [ -f "$SRC_DIR/template.cpp" ]; then
            cp "$SRC_DIR/template.cpp" "$solution_file" || error_exit "Failed to copy template" 1
            print_success "Created solution: $solution_file"
        else
            error_exit "Template file not found: $SRC_DIR/template.cpp" 2
        fi
    fi
    
    # Create problem.txt file
    local problem_file="$problem_dir/problem.txt"
    
    if [ -f "$problem_file" ]; then
        print_info "Problem file already exists: $problem_file"
    else
        cat > "$problem_file" << 'EOF' || error_exit "Failed to create problem file" 1
# Paste the problem statement here from Codeforces

Examples
Input


Output


EOF
        print_success "Created problem file: $problem_file"
    fi
    
    # Compile to verify setup
    print_info "Verifying compilation..."
    local output_file
    output_file=$(mktemp) || error_exit "Failed to create temp file" 1
    trap "rm -f $output_file" RETURN
    
    if safe_compile "$solution_file" "$output_file"; then
        print_success "Compilation verified"
    else
        error_exit "Compilation failed. Check your C++ compiler." 1
    fi
    
    # Open files in VS Code if available
    if command -v code &> /dev/null; then
        print_info "Opening files in VS Code..."
        code "$problem_file" "$solution_file" 2>/dev/null || true
        print_success "Opened in VS Code"
    fi
    
    echo ""
    echo "Next steps:"
    echo "  1. Paste problem statement in $problem_file"
    echo "  2. Edit solution in $solution_file"
    echo "  3. cd $problem_name && cf problem.txt"
}

# ==================== RUN COMMAND ====================

cmd_run() {
    local input_arg="$1"
    
    # Find .cpp file in current directory
    local cpp_file=""
    
    # First, look for solution.cpp in current directory
    if [ -f "$PWD/solution.cpp" ]; then
        cpp_file="$PWD/solution.cpp"
    else
        # Otherwise, find any .cpp file in current directory
        cpp_file=$(find "$PWD" -maxdepth 1 -name "*.cpp" -type f 2>/dev/null | head -1)
    fi
    
    if [ -z "$cpp_file" ]; then
        error_exit "No C++ file found in current directory ($PWD)" 2
    fi
    
    print_info "Using: $(basename "$cpp_file")"
    
    # Prepare output file
    local output_file
    output_file=$(mktemp) || error_exit "Failed to create temp file" 1
    trap "rm -f $output_file" RETURN
    
    # Compile
    print_info "Compiling with $COMPILER..."
    if ! safe_compile "$cpp_file" "$output_file"; then
        return 1
    fi
    print_success "Compiled successfully"
    
    # Prepare input
    local input_data=""
    local expected_output=""
    local is_problem_file=false
    local temp_input=""
    
    if [ -n "$input_arg" ]; then
        if [ -f "$input_arg" ]; then
            # Input is a file - extract test input intelligently
            print_info "Running with input from: $input_arg"
            input_data=$(extract_test_input "$input_arg") || true
            
            # Check if this is a problem file and extract expected output
            if grep -qi "Examples" "$input_arg" 2>/dev/null; then
                is_problem_file=true
                expected_output=$(extract_expected_output "$input_arg") || true
            fi
            
            # Create temp input file
            temp_input=$(mktemp) || error_exit "Failed to create temp input file" 1
            echo -n "$input_data" > "$temp_input"
            trap "rm -f $output_file $temp_input" RETURN
        else
            # Input is a string (possibly with escaped newlines)
            print_info "Running with inline input"
            # Interpret escape sequences
            input_data=$(printf "%b" "$input_arg") || true
            
            # Create temp input file
            temp_input=$(mktemp) || error_exit "Failed to create temp input file" 1
            echo -n "$input_data" > "$temp_input"
            trap "rm -f $output_file $temp_input" RETURN
        fi
    else
        print_info "Running with stdin (pipe input or interactive)"
    fi
    
    # Execute with input
    echo ""
    print_info "Your Output:"
    echo "---"
    
    local actual_output=""
    if [ -n "$temp_input" ]; then
        actual_output=$(safe_execute "$output_file" "$temp_input") || return 1
        echo "$actual_output"
    else
        safe_execute "$output_file" || return 1
    fi
    
    echo "---"
    
    # Display expected output if available
    if [ "$is_problem_file" = true ] && [ -n "$expected_output" ]; then
        echo ""
        print_info "Expected Output:"
        echo "---"
        echo "$expected_output"
        echo "---"
        
        # Compare outputs (simple comparison)
        if [ "$actual_output" = "$expected_output" ]; then
            print_success "✓ Output matches expected!"
        else
            print_warning "✗ Output does not match expected"
        fi
    fi
    
    print_success "Execution complete"
}

# ==================== TEST COMMAND ====================

cmd_test() {
    print_info "Running test suite..."
    
    if [ ! -f "$SCRIPTS_DIR/test.sh" ]; then
        print_warning "Test script not found: $SCRIPTS_DIR/test.sh"
        print_info "Using fallback: testing template.cpp"
        
        if [ ! -f "$SRC_DIR/template.cpp" ]; then
            error_exit "Template file not found" 2
        fi
        
        # Basic test
        local output_file
        output_file=$(mktemp) || error_exit "Failed to create temp file" 1
        trap "rm -f $output_file" RETURN
        
        if safe_compile "$SRC_DIR/template.cpp" "$output_file"; then
            print_success "Template compiles successfully"
        else
            return 1
        fi
    else
        bash "$SCRIPTS_DIR/test.sh"
    fi
}

# ==================== HELP COMMAND ====================

cmd_help() {
    cat << 'EOF'
cf - Codeforces CLI Tool

USAGE:
  cf <command> [args]

COMMANDS:
  template <name>    Create new problem template
  test               Run test suite with validation
  help               Show this help message

EXAMPLES:
  cf template 1000A           Create new problem 1000A
  cf problem.txt              Run solution with input from file
  cf "5\n1 2 3 4 5"           Run solution with inline input
  cf test                     Run test suite

FEATURES:
  ✓ Auto-detects .cpp files in current directory
  ✓ Timeout protection (5s) prevents infinite loops
  ✓ Validates input and handles errors gracefully
  ✓ Compares output with expected results
  ✓ Cross-platform (Linux/macOS/WSL)
  ✓ Production-grade reliability

ENVIRONMENT:
  CF_REPO_ROOT     Override repository root directory
  CF_VERBOSE       Set to 1 for debug output

NEXT STEPS:
  1. Create a template: cf template 1000A
  2. Edit the solution in 1000A/solution.cpp
  3. Run with test input: cf problem.txt
  4. Submit to Codeforces

For more information, visit: https://github.com/yourusername/cf

EOF
}

# ==================== MAIN ENTRY POINT ====================

main() {
    # Parse command
    local command="${1:-}"
    shift || true
    
    case "$command" in
        template)
            # Validate repo structure for template command
            if [ ! -d "$SRC_DIR" ]; then
                error_exit "Repository structure not found. Expected $SRC_DIR" 2
            fi
            cmd_template "$@"
            ;;
        test)
            # Validate repo structure for test command
            if [ ! -d "$SRC_DIR" ]; then
                error_exit "Repository structure not found. Expected $SRC_DIR" 2
            fi
            cmd_test "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        "")
            print_error "Usage: cf <command> [args]"
            echo ""
            echo "Commands:"
            echo "  cf template <name>     Create new problem template"
            echo "  cf [input]             Compile and run solution"
            echo "  cf test                Run test suite"
            echo "  cf help                Show help"
            echo ""
            echo "For more information: cf help"
            return 1
            ;;
        *)
            cmd_run "$command" "$@"
            ;;
    esac
}

main "$@"
